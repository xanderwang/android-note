{"meta":{"title":"Xander's blog","subtitle":"Android blog","description":"My blog for Android","author":"Xander Wang","url":"https://xanderwang.github.io/android-note","root":"/android-note/"},"pages":[{"title":"关于我","date":"2021-02-24T04:52:56.000Z","updated":"2021-02-28T07:55:56.187Z","comments":true,"path":"about/index.html","permalink":"https://xanderwang.github.io/android-note/about/index.html","excerpt":"","text":"Github: https://github.com/XanderWang CSDN: https://blog.csdn.net/wxy318 Mail: &#x34;&#x32;&#x30;&#54;&#x34;&#48;&#55;&#x36;&#x33;&#64;&#113;&#x71;&#x2e;&#99;&#111;&#x6d; 微信:"},{"title":"归档","date":"2021-02-28T07:55:56.187Z","updated":"2021-02-28T07:55:56.187Z","comments":true,"path":"archives/index.html","permalink":"https://xanderwang.github.io/android-note/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-02-28T07:55:56.187Z","updated":"2021-02-28T07:55:56.187Z","comments":true,"path":"categories/index.html","permalink":"https://xanderwang.github.io/android-note/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-05-18T05:27:50.000Z","updated":"2021-02-28T07:55:56.187Z","comments":true,"path":"tags/index.html","permalink":"https://xanderwang.github.io/android-note/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"总结笔记(六) - 网络编程总结","slug":"总结笔记(六) - 网络编程总结","date":"2021-02-26T13:31:00.000Z","updated":"2021-02-28T07:55:56.187Z","comments":true,"path":"2021/02/26/总结笔记(六) - 网络编程总结/","link":"","permalink":"https://xanderwang.github.io/android-note/2021/02/26/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0(%E5%85%AD)%20-%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/","excerpt":"","text":"网络编程总结网络协议总览网络协议分层 网络协议框架 各层协议之间的区别合联系应用层: Http WebSocket FTP 等 传输层: TCP UDP 网络层: IP 链路层: - TCP 和 UDP TCP 是面向连接的一种传输控制协议。TCP 链接连通后，客户端和服务器可以互相发送和接收消息。在客户端或者服务端没有主动断开链接的情况下，链接一直存在，所以一般 TCP 也成为长链接。TCP 的特点是，连接有耗时(三次握手)，数据传输无限制，准确可靠。 UDP 是无连接的用户数据报协议。无连接就是传输数据前不用建立连接，直接向指定位置传输数据。特点是速度快，但不稳定，可广播，数据大小有限制。 两者比较的话， TCP 可以类比打电话， UDP 可以类比发短信。 HTTP HTTP 是基于 TCP 协议的，请求时，建立 TCP 连接，请求结束后断开连接。HTTP v1.1 版本新增了 keep-alive ，可以复用之前的 TCP 连接，减少资源消耗。这个也是网络优化的一个点。 WebSocket WebSocket 也是一种协议，属于应用层。WebSocket 协议分为 2 部分，一部分为”连接”，一部分为”数据传输”。 Socket 连接和 TCP 连接 Socket 是传输层的门面，TCP 和 UDP 是一个协议，应用层和传输层之间的交互是通过 Socket 来实现的。 HTTP 和 WebSocket 的区别 都是应用层的协议，而且都是基于 TCP 协议的，不同的是 HTTP 无状态的一次连接后就会关闭， WebSocket 是全双工的，连接后可以互相发送和接收消息。 HTTP 协议HTTP 协议是什么HTTP 协议的中文翻译是超文本传输协议，从字面的意思来看，HTTP 协议是用来解决互联网上的机器之间如何传输超文本内容问题的协议。 HTTP 协议是如何工作的HTTP 协议是用来解决互联网上 2 台机器之间传输超文本内容的问题的。我们先看一个基础的问题， 2 台机器如何传输数据。 这是一个很复杂的问题，涉及到软硬件之前的协作。直接通讯肯定和硬件相关，通讯的内容是什么和软件相关。为了更好的发展，或者说减少网络开发的门槛，整个网络相关的开发(软硬件)，理论上分成了 7 层，实际实现了 4 层。 分层设计的好处就是各层相互独立，同时减少耦合，提高了开发效率，易扩展。 HTTP 协议是建立在 TCP/IP 的基础上的，属于应用层。 数据在网络上的流向大概下面 发送方机器应用层封装原始数据后传给传输层。 -&gt; 传输层接收应用层数据后封装数据，然后把数据传递给网络层。 -&gt; 网络层接收数据后封装数据，然后把数据传递给链路层。 -&gt; 链路层把数据交给网络，最终数据传递到了接收方机器 -&gt; 接收方机器链路层收到发送方链路层的数据 -&gt; 接收方网络层接收到链路层数据，解开数据后传给传输层 -&gt; 接收方传输层接收到数据后，解开数据，然后把数据传给应用层 -&gt; 接收方应用层接收到数据后，解析数据然后展示。 TCP/IP 的三次握手和四次挥手三次握手上一小节简单描述了数据在整个网络中的大概流向。有一些相对来说关键且重要的问题。 如何保证接收方是我们的期望接收方？ 如何能保证网络相对稳定可靠，即 C 和 S 都觉得对方和自己都是可以接收和发送消息的？ 三次握手就是用来解决这些关键问题的，主要是解决问题 2 的，因为问题1 不管是几次握手都需要解决的。 先说下三次握手是如何工作的，然后再说下为什么是三次握手。 第一次握手: C 端 发送 SYN=1 信号，同时 seq=x 来请求 S 端 第二次握手: S 端 发送 SYN=1 ACK=1 信号，同时 seq=y ack=x+1 给 C 端，表示对 C 的 SYN 信号应答，同时发送一个 SYN 第三次握手: C 端发送一个 ACK=1 信号，同时 ack=y+1 ，服务器接收到后就可以开始传输数了， 因为经过三次握手， C 端确认了自己是可以发送和接收的，S 端也是可以发送和接收的(1-2握手)。S 端也确认了自己是可以发送和接收的，同时 C 端也是可以接收和发送的(2-3握手)。 四次挥手tcp/ip 是全双工的，就是说 C 和 S 都是有发送和接收的。断开的时候需要发送和接收都断开。所以需要四次挥手来做到。 第一次挥手 C 发送 FIN=1 信号， seq=u ，接着 C 关闭发送数据，就是说后续不能发送数据流，表示数据发送完。 第二次挥手 S 发送 ACK=1 信号，ack=u+1,seq=v 表示接收到了 C 的 FIN 信号。 第三次挥手 S 发送 FIN=1,ACK=1 信号，同时 seq=w,ack=u+1 然后 S 关闭接收数据，即后续 S 不在接收数据，数据发送完了。 第四次挥手 C 端接收到第三次挥手的请求后，发送 ACK=1 信号，表示确认接受完数据， S 端可以关闭接收了，2 timel 后 C 端关闭接收。同时 S 端接收到第四次挥手请求后，S 端关闭接收 至此，挥手完毕。 重学TCP/IP协议和三次握手四次挥手 如何理解 HTTP 协议是无状态的，无连接的无连接，或者叫无持续连接合适些。最早的协议，一次处理一个连接，连接处理完后，就断开，后续加了 keep-alive 来解决这个问题。 无状态，是指两次连接之间没有关系，不会记录两次连接之间的关系。实际交互也许有关系，但是作为两次连接，在通讯的时候，是没有关系的，就是不会直接有影响两次连接。这是协议的内容，但是实际搞了个 cookies http协议无状态中的 “状态” 到底指的是什么？！ HTTP 各个版本比较 http 0.9 http 1.0 新增了 POST GET PUT 等方式，新增了请求头和响应头概念，扩充了传输的内容格式。图片等都可以传输了。 http 1.1 目前引用最广泛的协议，做了优化，支持 keep-alive，管道化、断点续传。 http 2.0 主要是改进传输性能，实现低延迟和高吞吐。采用二进制传输数据。 http 3.0 将弃用TCP协议，改为使用基于UDP协议的QUIC协议实现。 GET 和 POST 的区别 语义上的区别， GET 用户请求数据，一般请求到的内容是固定的， POST 一般是向服务器提交数据。 GET 请求参数在 url 中， post 请求参数在 request body 里面。 GET 是安全、幂等和可缓存的， POST 是不安全，不幂等和不可缓存的。(安全是说，资源是只读的，幂等是指请求一次或者多次，返回的结果都是一样的。可缓存的) 参考资料: GET 和 POST 到底有什么区别？ TCP、UDP、HTTP、SOCKET、WebSocket之间的区别 1小时教你理解HTTP，TCP，UDP，Socket，WebSocket HTTPS 协议原理HTTPS 是在 HTTP 中加入了一层 SSL/TLS 加密层，用来保护中间数据的安全。 需要注意的而是 HTTP 和 HTTPS 都是基于 TCP/IP 协议的，就是说 HTTPS 先进行三次握手建立链接后，才做证书认证等 在介绍 HTTPS 之前，我们先简单介绍下密码学的一些基础知识。 明文: 未被加密的原始数据 密文: 加密后的数据，无法直接查看，需要通过解密后才可以查看 密钥: 一种参数，用于明文转为密文，或者密文转为明文时候的参数，分为对称密钥和非对称密钥。 对称加密: 也叫私钥加密，即数据的发送者和接收者用的是用一个密钥来加密和解密数据。加密过程中的密钥称为私钥，即不能公开，私人所有。公开后或者泄露后，第三方很容易解密密文。 非对称加密:也叫做公钥加密。密钥是一对，分为公钥和密钥，加密的时候可以用公钥或者密钥中的一个加密，解密的时候需要用另外一个密钥解密。 HTTPS 实际上是 HTTP 协议 + SSL/TLS 协议，就是说内容通过 SSL/TLS 协议加密后，在通过 HTTP 协议传输。 HTTPS 涉及到了对称加密和非对称加密，可以分为 8 个小步骤 客户端向服务器 443 端口发起 HTTPS 请求。 服务器接收到请求后，找到保存的公钥和密钥。 服务器发送公钥(也就是证书)给客户端。 客户端接收到公钥后，验证公钥是否有效，如果无效，提示异常；如果有效，那么生成一个随机的密钥。 客户端用公钥对这个生成的密钥加密后发送给服务器。 服务器接收到加密后的随机密钥后，服务器用密钥加密后的带随机密钥。 服务器用随机密钥加密数据后发送给服务器。 客户端接收到数据后用随机密钥解密，就可以得到数据。 这里面涉及到了非对称加密和对称加密。 非对称加密用于校验网站公钥，也就是证书。同时用来加密客户端生成的随机密钥 随机密钥用于对称加密，用于加密数据。 第 4 步的验证公钥是否有效，需要说到公钥(证书)的来由，是由网站去 CA 组织申请的，申请通过后，CA 会用自己的私钥对网站信息，授权的期限等信息加密后生成的一个数字证书。简单说就是网站的公钥(证书)是 CA 组织私钥加密后的产物，然后终端设备都会内置 CA 组织的所有公钥。在终端设备拿到网站证书后，会用内置的 CA 公钥对网站证书解密，如果成功解密，就可以根据解密后的信息来判断当前证书是否有效，如果不能解密成功，说明网站公钥(证书)无效。 Https原理及流程 HTTPS理论基础及其在Android中的最佳实践 HTTP 和 HTTPS 的区别HTTPS 加密的 网络开源库框架有哪些 httpclient 废弃不用了 volley 基本不用了 okhttp 在用，主流网络请求框架 okhttp 源码解析1 创建一个 OkHttpClient 2 创建一个 Request 3 调用 OkHttpClient 的 newCall 方法后生成一个 RealCall 4 调用 RealCall 的 execute 同步开始请求或者异步加入队列 5 同步调用的时候会调用 RealInterceptorChain 的 proceed 方法，这个方法做的事情主要是通过找到 interceptor ，然后把任务交给 interceptor 的 intercept 方法继续执行。 OKHttp源码解析(一)–初阶 如何优化网络 开启 Gzip 压缩，开启后可以减少数据传输的大小，减少数据传输时间。 考虑用 Protocol Buffer 代替 JSON 或者 XML， XML 肯定是需要替换的。 OKHttp 接入 HTTPDNS，在 OkHttp.build() 时，通过 dns() 方法配置。HTTPDNS 的好处就是绕过运营商的 LocalDNS 解析，提高解析效率和有效防止域名劫持。 okhttpClient 尽量只创建一个实例。这样请求都在一个线程池里面。 参考资料: OkHttp3线程池相关之Dispatcher中的ExecutorService","categories":[{"name":"编程基础","slug":"编程基础","permalink":"https://xanderwang.github.io/android-note/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"https://xanderwang.github.io/android-note/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"HTTP","slug":"HTTP","permalink":"https://xanderwang.github.io/android-note/tags/HTTP/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://xanderwang.github.io/android-note/tags/HTTPS/"},{"name":"三次握手","slug":"三次握手","permalink":"https://xanderwang.github.io/android-note/tags/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"}]},{"title":"总结笔记(五) - Java 线程总结","slug":"总结笔记(五) - Java 线程总结","date":"2021-02-26T13:30:00.000Z","updated":"2021-02-28T07:55:56.187Z","comments":true,"path":"2021/02/26/总结笔记(五) - Java 线程总结/","link":"","permalink":"https://xanderwang.github.io/android-note/2021/02/26/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0(%E4%BA%94)%20-%20Java%20%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/","excerpt":"","text":"Java 线程总结Java 线程安全什么是线程安全在上一节的 Java 内存模型里面说到，程序在运行的时候，线程并不是直接从主存里面，而是先从主内存拷贝一份到工作内存(线程私有的)，然后执行代码，最后把计算结果从工作内存写回到主内存。 有个小问题，为是么需要 JMM ？ cpu 在存取数据或者存取指令的时候，如果都是在一片连续的区域，效率会高，所以栈里面会有一个变量的副本，这样会把需要参与计算的变量放到一片连续的区域，会提高执行效率，但是这样就会有一个数一致性问题，也就是线程安全问题。说到底就是数据同步问题。 当有多个线程同时访问同一个变量的时候，因为线程在运算的时候，可能并不是拿的“最新”的值来参与计算的，或者说，参与计算的值不是“最新的”，因为其他线程更新了这个变量，但是线程不知道，还是用的“旧的值”。最终，执行完代码后，写回到主存的值是不符合预期的值。这种情况就是线程不安全，所以，对应的，线程安全就是多个线程同时访问同一个变量的时候，最终的结果和预期结果一致，就表明是线程安全的。 线程要保证安全，需要满足三个条件 原子性(Synchronized / Lock) 原子性的意思是，某个操作要么执行完，要么不做。比如读取值，执行时，开始读数据了，需要保证不能被打断。要么不读值。 可见性(Volatile / Synchronized / Lock) 可见性的意思是对值得读写可以立刻捕获，就是说某个线程可以“观察”到其他线程对值得修改，同时，这个线程对值的修改，其他线程也可以“观察”到。 有序性(Volatile / Synchronized / Lock) 说到有序性需要说到指令重排，指令重排是为了提高 CPU 的指令执行效率，执行代码的时候，会把一些源码上的不影响方法执行结果的代码打乱执行，以提高 CPU 执行效率。有序性的意思就是说最终代码编译的指令是按照代码的书写顺序执行的。 Volatile上面说到了，线程安全在于没有“及时”读取到最新的值。要想“及时”读取到最新的值，我们需要用到 volatile 关键字，我们先看看值是如何读取的。 Java 变量的读写Java 变量读的读写是以下的指令来完成的，通过以下的指令，把变量的值从主内存读取到工作内存，工作内存变化后，写入主内存。 指令 含义 lock 作用于主内存，把变量标识为线程独占状态。 unlock 作用于主内存，解除独占状态。 read 作用主内存，把一个变量的值从主内存传输到线程的工作内存。 load 作用于工作内存，把 read 操作传过来的变量值放入工作内存的变量副本中。 use 作用工作内存，把工作内存当中的一个变量值传给执行引擎。 assign 作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。 store 作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。 write 作用于主内存的变量，把 store 操作传来的变量的值放入主内存的变量中。 volatile 如何保持内存可见性 read、load、use 动作必须连续出现。 assign、store、write 动作必须连续出现。 所以，使用 volatile 变量能够保证: 每次读取前必须先从主内存刷新最新的值。 每次写入后必须立即同步回主内存当中。 有了这 2 条规则，线程就可以及时“观察”到变量值得变化了。 volatile 如何防止指令重排序通过内存屏障来实现的。 屏障 举例 含义 LoadLoad Load1;LoadLoad;Load2 Load2 以及之后的读操作要在 Load1 完成之后 LoadStore Load1;LoadStore;Store Store2 以及之后的写操作要在 Load1 完成之后 StoreStore Store1;StoreStore;Store2 Store2 以及之后的写操作要在 Store1 完成之后 StoreLoad Store1;StoreLoad;Load2 Load2 以及之后的读操作需要在 Store1 完成之后 为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。然而，对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，Java内存模型采取保守策略。 下面是基于保守策略的JMM内存屏障插入策略： 在每个 volatile 写操作的前面插入一个 StoreStore 屏障。 在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。 在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。 在每个 volatile 读操作的后面插入一个 LoadStore 屏障。 volatile关键字的作用、原理 Java内存模型 JVM内存模型、指令重排、内存屏障概念解析 解决这个问题(线程不安全)的办法有以下几种方式 synchronized Lock + volatile 说到底，线程安全的主要的思想就是利用某种方式，保证同时只有一个线程在使用这个变量或者说是方法块，其他的线程“阻塞”，等待正在执行的线程执行完。线程油冰雪执行变成串行执行。 线程安全的实现方式synchronizedsynchronized 通过字节码指令 enterMoniter 和 exitMoniter 实现同时只有一个线程可以执行某段代码块，等这段代码块执行完以后，其他的线程才可以执行。 这里面需要了解 synchronized 的作用对象，作用对象是一个 Object 。 大概的原理就是:每个对象都有一个对象头，这个对象头里面存储了相应的锁的信息(无锁、偏向锁、轻量锁和重量锁)。当代码执行到 synchronized 代码的时候，会看这个锁作用的对象的对象头，是有锁还是无锁，无锁就加锁后继续执行。有锁后就阻塞，等待其他线程执行完。 但是一开始 synchronized 是一个比较重的操作，后续做了优化，这些优化分别是自旋锁、轻量锁、偏向锁。 自旋就是不会立即 block 线程，而是做一段小的自循环，如果还是无法获取锁，再 block 线程。 轻量锁是指，虽然对于同一段代码，有多个线程竞争，但是竞争发生在不同的时间段。轻量锁的做法是第一次对锁对象加锁的时候，锁对象的对象头记录指向线程中的锁记录。再次执行代码，加锁锁对象的时候，如果锁对象的对象头指向的锁记录是这个线程，就直接执行，跳过加锁过程。 偏向锁就是，锁对象被加锁的时候，锁对象的对象头会保存持有锁的线程 id , 当同步代码执行完后，再次对锁对象加锁的时候，如果锁对象的对象头是偏向锁，并且 thread id 是当前线程，那么就不做加锁过程，直接执行。 轻量级锁和偏向锁如果存在竞争，最终还是会膨胀为重量锁的。 锁膨胀过程偏向锁(01)：做一次 cas 操作，如果成功，说明获取偏向锁成功，对象头记录获取锁的 ThreadId ，如果失败，说明有竞争，这个时候需要膨胀为轻量级锁。 轻量级锁(00)：某个线程获取锁的时候，如果对象头是偏向锁，就看 ThreadId 对应的线程是否还活着，如果活着，就看是否退出同步块，如果不存活或者已经退出同步块，就尝试 cas 操作获取偏向锁，如果 cas 失败，说明有竞争，这个时候需要由偏向锁膨胀为轻量级锁，具体的过程就是 JVM 会把当前获取锁的线程挂起，然后再线程的当前栈帧里面创建一个锁记录，然后把对象头用 CAS 拷贝进去，同时创建一个 Owner 指针指向锁对象的对象头，然后锁对象的对象头指向这个锁记录，然后之前获取锁的线程继续执行，没有获取到锁的线程先自旋一段时间，如果自旋结束后成功获取到轻量级锁，就继续执行，如果自旋后还是获取不到轻量级锁，说明由更严重(多个线程)的竞争，需要膨胀为重量级锁。 重量级锁(10)：线程 参考资料： https://juejin.im/post/5ca766dcf265da30d02fb35c JAVA锁的膨胀过程和优化 聊聊Java 锁的JVM锁 JAVA锁的膨胀过程和优化 Lock + volatilelock 的话主要是利用 AQS 框架来实现的同步机制。 AQS 框架内部利用了 CAS 来判断是否有线程持有锁。当有其他线程持有锁的时候，会 block 当前线程，然后入队列(入队的时候可能会有自旋)，当持有锁的线程释放锁后，会唤醒 block 的线程。 CAS 是 Java 提供的原子性操作 API 。 AQS 框架的理解： acquire 独占式获取锁，如果没有获取成功，就入队列并阻塞。 tryAcquire 独占式锁子类需要复写的方法，独占式请求锁。返回 true 表示线程获取锁成功，false 表示获取锁失败。 acquireShare 共享式获取锁，当获取锁的线程数量超过指定数量(tryAcquireShare的返回结果小于0)，就阻塞尝试获取锁的线程。 tryAcquireShare 共享式锁子类需要复写的方法。返回值如果小于 0 表示共享锁的数量消耗完，需要阻塞。 acquireQueued 独占的时候，入队列 addWaiter 具体的入队列入口 doAcquireShared 共享的时候，入队列 Java 里锁的分类 公平/非公平锁 公平：按照请求锁的时间顺序依次获取锁，非公平锁就是不一定是按照请求锁的时间顺序来获取锁的。 独占/共享锁 独占锁(ReentrantLock)就是锁只能同时被一个线程持有，共享锁(CountDownLatch/Semaphone)就是锁可以同时被多个线程持有。 自旋锁 没有请求到锁的时候，做一段循环，等待持有锁的线程释放锁，然后请求锁。坏处就是，如果自旋过久，也会消耗大量的 cpu 资源。 偏向锁/轻量锁/重量锁 synchornized 的优化，如果再偏向锁发生竞争的时候会锁膨胀 可重入/不可重入 线程获取某个锁后，再次请求这个锁，仍然可以获取锁就是可重入锁。反之，获取锁后，再次请求这个锁，无法获取到锁就是不可重入锁。 可中断锁 这个待完善。 常用锁的原理分析 ReentrantLock 可重入锁，独占式的，默认是非公平锁，可通过构造方法来决定是公平锁还是非公平锁。 调用 lock 方法去尝试获取锁。 调用 unlock 方法释放锁。 CountDownLatch await 方法，调用此方法的时候，只有当 state 为 0 的时候才不阻塞，state 为其他值的情况下会阻塞线程 CountDownLatch 构造方法需要指定 count , 也就是 state countDown 方法，会使 count - 1 ，其实就是 count ，当 count - 1 == 0 的时候唤醒阻塞的线程。 适用于事情开始前，一些条件达成(条件达成，计数器减一)，然后继续。 需要注意的是 count 只有减少的方法，没有增加和重置的方法，故不可复用。 CyclicBarrier 强调的是，事情做完后，等其他线程也达到同等条件，然后在继续执行。 适用于事情做完后，等待某一条件达成，然后继续。 ReentrantReadWriteLock 里面包含读锁和写锁。读读不互斥，读写，写写互斥。就是两个线程都读数据的时候，不会阻塞，两个或者多个线程读写或者写写的时候会阻塞线程。 相对其他的锁，锁的粒度更小，效率会高一些，同样的，实现会复杂些。 默认是非公平锁，同样可以通过构造方法控制是否为公平锁。 read 锁为共享锁 write 锁为独占锁 这两个锁共用一个 AQS 框架的 state , state 高16位表示共享锁的 state , 低 16 为表示 write 锁的 state AQS 框架小结 上面的四种框架很好的利用了 AQS 框架，重点基本在 tryAcquire、tryAcquireShare 里面，这 2 个方法的返回值是子类控制AQS框架是否阻塞线程的入口，如果需要自定义一种锁的话，需要好好设计这两个方法。 ReentrantReadWriteLock 就是一个很好的例子。 线程间通信这种互相通信的过程就是线程间的协作 多线程之间通讯，其实就是多个线程在操作同一个资源，但是操作的动作不同 线程间通信方式 wait/notify synchornized 的时候，通过 wait/notify 来暂停线程和通知线程，从而达到通信的目的。 Object 类的方法，final 的，表示子类不可修改 wait(long time) 主动释放锁，然后休眠，在指定的时间长度后自动唤醒或者被系统唤醒。 notify() 随机唤醒一个等待的线程进入就绪队列 notifyAll() 唤醒所有等待的线程进入就绪队列 参考资料 JAVA线程通信详解 java condition使用及分析 lock/condition 这个其实和 wait/notify 类似，不过这个是语言层面实现的，不是虚拟机层面的实现。 管道 PipedInputStream/PipedOutputStream 来实现的，一个是开始，一个是结束。 Object 和 Thread 常用方法介绍 Object: 下面的方法都只能在同步块中调用 wait() 释放锁资源，并等待唤醒 wait(long time) 释放锁资源，并在指定事件后唤醒 notify() 随机唤醒一个线程进入就绪列表 notifyAll() 唤醒所有线程进入就绪列表 Thread: 类方法 sleep(long time) 让线程休眠指定事件，但是不释放锁资源。 join() 等待目标线程结束 线程池通过 ThreadPoolExcutor 类来创建线程池。 创建线程池 5 个参数的含义 参数 含义 corePoolSize 线程池的基本大小，即在没有任务需要执行的时候线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程 maximumPoolSize 线程池中允许的最大线程数，只有工作队列满了，才可能继续创建线程，但是同时运行的线程数不会超过这个 keepAliveTime 当 idle 的线程数大于 corePoolSize 时，idle 的线程可以存活的时间。 unit 时间单位 workQueue 没有被执行的任务会放到这个队列里面 threadFactory 用来创建新的线程的 handler 参考资料 理解ThreadPoolExecutor线程池的corePoolSize、maximumPoolSize和poolSize 探索 Android 多线程优化方法 一次Android线程优化的探索","categories":[{"name":"Java","slug":"Java","permalink":"https://xanderwang.github.io/android-note/categories/Java/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/tags/Android/"},{"name":"Java 线程","slug":"Java-线程","permalink":"https://xanderwang.github.io/android-note/tags/Java-%E7%BA%BF%E7%A8%8B/"}]},{"title":"总结笔记(四) - JVM 总结","slug":"总结笔记(四) - JVM 总结","date":"2021-02-26T13:29:00.000Z","updated":"2021-02-28T07:55:56.187Z","comments":true,"path":"2021/02/26/总结笔记(四) - JVM 总结/","link":"","permalink":"https://xanderwang.github.io/android-note/2021/02/26/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0(%E5%9B%9B)%20-%20JVM%20%E6%80%BB%E7%BB%93/","excerpt":"","text":"JVM 总结什么是 JVMJVM 是 Java 虚拟机，是一个虚拟出来的计算机，仿真模拟计算机。 JVM 在运行程序的时候，这个程序在 JVM 里面是怎么样的？JVM 的内存主要分为五块 程序计算器 程序计算器是用来记录当前线程的执行的位置，通过程序计数器的记录，程序就可以继续进行下去。 线程私有的，就是每个线程都不一样。 需要注意的是这里面没有 OutOfMemory 的异常，在执行 native 方法的时候，记录是空值，一些循环，比如 for 、 while 也是通过这个来实现的。 虚拟机栈 每一个线程都会有一个虚拟机栈，用于解释代码的执行过程。线程每调用一个方法的时候就会创建一个栈帧，并放到这个虚拟机栈中，方法执行完成后，这个栈帧出栈。 栈帧是什么呢？或者说里面是什么内容呢？栈帧主要包括以下 4 个内容： **局部变量表(LocalVariableTable)**，里面是这个方法里面的用到的变量，this 是下标为 0 的变量 操作数栈，JVM 是基于栈的，操作数可以理解为中间的计算结果，结果是保存在栈里面的。 动态链接，在加载类的时候，类的字段和方法对应的内存布局之间的连接。 返回值，方法的返回值 线程私有的，就是每个线程都不一样。 本地方法栈 和虚拟机栈类型，不过这里面具体就要看 native 层的了。 线程私有的，就是每个线程都不一样。 方法区 类被加载后，类的属性、方法等信息会保存在这里。 堆 一般 new 出来的实例都是放在这里的。其他的部分在方法区里面的常量池。 那，哪些不在堆里面呢？？？ 那些不在堆里面分配的对象实例可能在栈里面，具体的就哟啊说到逃逸分析了，这里 https://juejin.im/post/6844904086010069006 https://zhuanlan.zhihu.com/p/94568794 一个 class 字节码文件里，类的结构是如何的？类的结构可以粗略看出是一些无符号数和一些表组成的，表里面可以包含其他的表，大概的结构如下。 魔数 大小版本号 常量池(表结构) 访问flag 父类 接口列表(表结构) 字段表(表结构) 方法表(表结构) 属性表(表结构) 表结构由表的元素个数 count 和表的内容组成，表的内容可以是无符号数和表。不同的表，表的内容的每一项结构都是固定和相同的。 常量池里面的每一项都是表 JVM 是如何找到一个类的JVM 是通过 ClassLoader 来加载类的。 ClassLoader 的 loadClass 方法可以让系统找到一个类。 ClassLoader loadClass 的时候用到了双亲委派模式来加载一个类。先判断是否加载过，如果没有加载过，就先交给父类来加载，如果父类也没有加载过，再回到自己，自己去加载。 Java 里面的双亲委派并不是很强制的，可以通过复写 ClassLoader 的 loadClass 方法来破坏这种双亲委派模式，从而达到加载自己的类过程。 ClassLoader 加载类一般是从指定的路径下加载类的，双亲委派模型能保证先优先从顶层的类加载器来加载类，而顶层的类加载器一般是系统提供的，系统提供的类加载器都是加载的指定位置的类库，这样能保证系统类不被篡改。 另外 ClassLoader 的 defindClass 可以通过一个 byte 数组来定义一个类。 JVM 加载类的时候，有哪些过程呢？类加载可以分为三大步(分别是，载入、连接和初始化)，也可以说是 5 个步骤。 类的加载过程： 加载 从二进制流加载类，主要做了三件事情 a. 通过类的全限定名查找 .class 文件，并生成二进制流 b. 解析 .class 文件，主要就是按照 Class 类的结构解析，生成 JVM 特定的数据结构并保存在方法区。 c. 生成一个 Class 类的实例，后续对这个类的访问可以通过这个 Class 的实例来完成。 链接，可细分为一下三小步 验证 校验版本号是否符合要求，高版本 class 不能在低版本 JVM 上运行 准备 给类的静态变量赋初始值，final 类型赋值。 解析 主要是把常量池里面的符号引用转为直接引用。 初始化 主要执行静态代码块、调用构造器的构造方法。 类的生命周期，除了加载过程中的 5 个阶段，还有使用和卸载 2 种阶段。 Java 内存模型之前说过，每个线程都有自己的程序计数器、虚拟机栈和本地方法栈。每个线程都是不一样的，还说过 JVM 是虚拟的一个硬件平台。那么 JVM 具体在执行一个线程的时候内存的情况是如何的呢？ 线程工作的时候，会给线程分配一个内存空间，我们称之为工作内存，然后还有一个主内存。 线程在工作的时候， JVM 会先从主内存把数据载入工作内存，计算完成以后，在把最后的结果“写回”到主内存。 为什么要这样先载入最后写回？可能是因为载入的指令比较耗时吧。 JVM GC四种索引 强引用。默认就是强引用，即使内存不够也不会释放。 软引用。SoftRefrence，内存不够的时候，会断开链接，然后释放内存。 弱引用。WeakRefrence，gc 的时候，如果发现了弱引用，就会释放，而不管是否内存不足。需要注意的是，可能需要多次 gc 才有可能找到这个弱引用，因为不同的 gc 清理或者说计算的内存区域不一样。 虚引用。代码里面无法直接使用。无法通过 get 方法获取引用对象。 软引用和弱引用在创建的时候可同时传入一个ReferenceQueue，当引用的对象被回收的时候，ref 实例会被放到 Queue 里面。 GC 的类型 GC_FOR_MALLOC 表示在堆上分配内存不足 GC_CONCURRENT 表示堆内存达到一定量的值，系统触发 GC_BEFOR_OOM 准备抛出 oom 异常 GC_EXPLICIT 调用系统方法 system.gc 软引用在前三个 gc 的时候释放，弱引用在创建后，下一次 gc 的时候释放。 回收算法DVM 和 JVM 区别，或者说是如何优化的DVM 基于寄存器， JVM 基于栈 基于寄存器的优点是字节指令少，执行效率高，易优化，缺点就是实现复杂 基于栈的有点就是易移植，相对容易实现。缺点就是效率慢，指令多。 ART 虚拟机是在 DVM 上做了优化。但还是基于寄存器的。 https://www.cnblogs.com/qdhxhz/p/10646088.html","categories":[{"name":"Java","slug":"Java","permalink":"https://xanderwang.github.io/android-note/categories/Java/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/tags/Android/"},{"name":"JVM","slug":"JVM","permalink":"https://xanderwang.github.io/android-note/tags/JVM/"}]},{"title":"利用 GitHub 搭建自己的个人博客","slug":"利用 GitHub 搭建自己的个人博客","date":"2021-02-25T14:41:00.000Z","updated":"2021-02-28T07:55:56.187Z","comments":true,"path":"2021/02/25/利用 GitHub 搭建自己的个人博客/","link":"","permalink":"https://xanderwang.github.io/android-note/2021/02/25/%E5%88%A9%E7%94%A8%20GitHub%20%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"先看下预览图吧。 先说下方案: GitHub Page + GitHub Action + hexo &amp; 配套主题 GitHub Page这个都不陌生吧，注册 GitHub 账号后，可以帮你托管你的 repository 下的静态网页，比如我有个 repository 叫 android-note ，我的 github 账号叫 xanderwang ，那么我的 android-note 托管后，访问地址就是： https://xander.github.io/android-note 托管后，如果我每次写了新的文章后，我把最新的静态 blog 上传上来，那么就可以更新自己的博客。 如果每次都可以自动编译和上传 blog 静态网页，那就很省事了。事实上，这个是可以做到的，具体细节后面再说。我们先看看如何托管我们的 repository 到 GitHub Page 。 最开始接触到 GitHub Page 的时候，看文章都是说需要新建一个和自己用户名同名的 repository ，然后往这个 repository 根目录里面上传静态 blog 网页，然后托管。 后来我发现不是这样，至少目前不是这样，我发现任意的 repository 都可以托管，只需要做一些特别的设置，如何设置呢？ 找到你的 repository ，然后 settings -&gt; GitHub Pages -&gt; Source -&gt; 选择分支和静态博客的目录(貌似只能选 / 或者 /doc) 到这里 GitHub 托管就设置好了。按照之前的规则你就可以访问你托管 blog 了。 GitHub Action刚刚说了，如果有个自动编译和上传 blog 的工具或者平台，每次我们写好 blog 后，自动帮我们编译上传好，那我们就可以省很多事。GitHub Action 正好可以做这个的，而且可以和 GitHub 无缝对接。那如何使用呢？ 很简单，只需要在你的 repository 里面新建 .github 文件夹，然后在里面新建 .workflows 文件夹，然后在里面新建 build.yml 文件(build 可以换成任意你喜欢的)，然后 GitHub Action 功能就开通了。这个时候， repository 下的目录结构大概是 . ├── .github │ └── workflows │ └── build.yml 现在介绍下如何配置 build.yml 文件 name: Xander&#39;s Blog Task # 在push **.md **.yml **.yaml **.sh 文件后执行任务 on: #配置任务执行时机 # Trigger the workflow on push or pull request, # but only for the master branch push: # branches: # - master paths: - &#39;**.md&#39; - &#39;**.yml&#39; - &#39;**.yaml&#39; - &#39;**.sh&#39; jobs: # 配置具体任务 build: # runs-on: macOS-latest runs-on: ubuntu-latest steps: # 引用外部 Action, 拉取代码仓库到虚拟机工作目录 - name: chekout code uses: actions/checkout@v1 # 执行 .sh 脚本文件，很多的任务可以在这个脚本里面执行 - name: build note run: sh ./blog_config/build.sh ... 上面列出了主要的步骤和解释了，具体可以参考我的 repository 这里需要说明的是，如果你需要额外传一些参数，比如密码是的，你需要现在 repository 做一些设置，具体参考如下： settings -&gt; secrets -&gt; 新建一个 secret 然后在你的 build.yml 里面使用 steps: - name: Hello world action with: # Set the secret as an input super_secret: $&#123;&#123; secrets.SuperSecret &#125;&#125; env: # Or as an environment variable super_secret: $&#123;&#123; secrets.SuperSecret &#125;&#125; run: | example-command &quot;$super_secret&quot; 到这里自动编译和发布的工作就说完了，现在我们还缺什么？ hexo &amp; 配套主题前面说了托管和自动编译和发布，现在我们就差一个个性化的静态 blog 模板了，这里我选择的是 hexo &amp; 配套主题。 hexo这个是一个静态的博客构建软件，配合网络上的主题，可以比较方便构建出自己的博客，同时有大量的精美主题可以选择。 如何安装就不具体说了，不是很难，官网有很详细的教程。 点我直达 hexo 官网 hexo 配套主题主题的话，一般可以在 GitHub 上面找，我暂时用的 volantis，可以去官网看下这个主题的具体介绍和相关配置。 这里说下可能遇到的坑的， 这里说下 _config.yml ... # URL ## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39; url: https://xanderwang.github.io/android-note root: /android-note/ # 需要注意这里的配置，注意 url 和 root 的配置，如果不是用的 GitHub 同名 repository 托管的，都需要配置 # Directory public_dir: docs # 公共文件夹，这个文件夹用于存放生成的站点文件。 # public_dir 目录就是 hexo 编译后存放静态 html 的目录，在托管 GitHub Page 的时候注意选择这个目录。 ... 其他的配置就是主题配置了，这个建议按照注意的 repository 或者主题的 demo 去配置，每个主题都是不一样的，只能靠自己的折腾了。","categories":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/categories/Android/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xanderwang.github.io/android-note/tags/hexo/"},{"name":"Github Action","slug":"Github-Action","permalink":"https://xanderwang.github.io/android-note/tags/Github-Action/"},{"name":"GitHub Page","slug":"GitHub-Page","permalink":"https://xanderwang.github.io/android-note/tags/GitHub-Page/"}]},{"title":"写了个 Android 性能检测的库，还有人看性能相关的么","slug":"写了个 Android 性能检测的库，还有人看性能相关的么","date":"2021-02-24T14:41:00.000Z","updated":"2021-02-28T07:55:56.187Z","comments":true,"path":"2021/02/24/写了个 Android 性能检测的库，还有人看性能相关的么/","link":"","permalink":"https://xanderwang.github.io/android-note/2021/02/24/%E5%86%99%E4%BA%86%E4%B8%AA%20Android%20%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B%E7%9A%84%E5%BA%93%EF%BC%8C%E8%BF%98%E6%9C%89%E4%BA%BA%E7%9C%8B%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B9%88/","excerpt":"","text":"简介由于本人工作需要，需要解决一些性能问题，虽然有 Profiler 、Systrace 等工具，但是无法实时监控，多少有些不方便，于是计划写一个能实时监控性能的小工具。经过学习大佬们的文章，最终完成了这个开源的性能实时检测库。初步能达到预期效果，这里做个记录，算是小结了。 开源库的地址是: https://github.com/XanderWang/performance 幸苦各位能给个小小的 star 鼓励下。 这个性能检测库，可以检测以下问题： UI 线程 block 检测。 App 的 FPS 检测。 线程的创建和启动监控以及线程池的创建监控。 IPC (进程间通讯)监控。 同时还实现了以下功能： 实时通过 logcat 打印检测到的问题。 保存检测到的信息到文件。 提供上报信息文件接口。 接入指南1 在 APP 工程目录下面的 build.gradle 添加如下内容。 dependencies &#123; // 必选 debugImplementation &quot;com.xander.performance:perf:0.1.12&quot; releaseImplementation &quot;com.xander.performance:perf-noop:0.1.12&quot; // hook 方案封装，必须添加 debugImplementation &quot;com.xander.performance:perf-hook:0.1.12&quot; // 以下是 hook 方案选择一个就好了。如果运行报错，就换另外一个，如果还是报错，就提个 issue // SandHook 方案，推荐添加。如果运行报错，可以替换为 epic 库。 debugImplementation &quot;com.xander.performance:perf-hook-sandhook:0.1.12&quot; // epic 方法。如果运行报错，可以替换为 SandHook。 // debugImplementation &quot;com.xander.performance:perf-hook-epic:0.1.12&quot; &#125; 2 APP 工程的 Application 类新增类似如下初始化代码。 Java 初始化示例 private void initPERF(final Context context) &#123; final PERF.LogFileUploader logFileUploader = new PERF.LogFileUploader() &#123; @Override public boolean upload(File logFile) &#123; return false; &#125; &#125;; PERF.init(new PERF.Builder() .checkUI(true, 100) // 检查 ui lock .checkIPC(true) // 检查 ipc 调用 .checkFps(true, 1000) // 检查 fps .checkThread(true) // 检查线程和线程池 .globalTag(&quot;test_perf&quot;) // 全局 logcat tag ,方便过滤 .cacheDirSupplier(new PERF.IssueSupplier&lt;File&gt;() &#123; @Override public File get() &#123; // issue 文件保存目录 return context.getCacheDir(); &#125; &#125;) .maxCacheSizeSupplier(new PERF.IssueSupplier&lt;Integer&gt;() &#123; @Override public Integer get() &#123; // issue 文件最大占用存储空间 return 10 * 1024 * 1024; &#125; &#125;) .uploaderSupplier(new PERF.IssueSupplier&lt;PERF.LogFileUploader&gt;() &#123; @Override public PERF.LogFileUploader get() &#123; // issue 文件上传接口 return logFileUploader; &#125; &#125;) .build()); &#125; kotlin 示例 private fun doUpload(log: File): Boolean &#123; return false &#125; private fun initPERF(context: Context) &#123; PERF.init(PERF.Builder() .checkUI(true, 100)// 检查 ui lock .checkIPC(true) // 检查 ipc 调用 .checkFps(true, 1000) // 检查 fps .checkThread(true)// 检查线程和线程池 .globalTag(&quot;test_perf&quot;)// 全局 logcat tag ,方便过滤 .cacheDirSupplier &#123; context.cacheDir &#125; // issue 文件保存目录 .maxCacheSizeSupplier &#123; 10 * 1024 * 1024 &#125; // issue 文件最大占用存储空间 .uploaderSupplier &#123; // issue 文件的上传接口实现 PERF.LogFileUploader &#123; logFile -&gt; doUpload(logFile) &#125; &#125; .build() ) &#125; 主要更新记录 0.1.12 线程创建的监控，加入 thread name 信息收集。同时接入 startup 库做必要的初始化，以及调整 mulit dex 的时候，配置文件找不到的问题。 0.1.11 优化 hook 方案的封装，通过 SandHook ,IPC 的监控可以按照耗时时间来检测。 0.1.10 FPS 的检测时间间隔从默认 2s 调整为 1s，同时支持自定义时间间隔。 0.1.9 优化线程池创建的监控。 0.1.8 初版发布，完成基本的功能。 不建议直接在线上使用这个库，在编写这个库，测试 hook 的时候，在不同的机器和 rom 上，会有不同的问题，这里建议先只在线下自测使用这个检测库。 原理介绍UI 线程 block 检测原理主要参考了 AndroidPerformanceMonitor 库的思路，对 UI 线程的 Looper 里面处理 Message 的过程进行监控。 具体做法是，在 Looper 开始处理 Message 前，在异步线程开启一个延时任务，用于后续收集信息。如果这个 Message 在指定的时间段内完成了处理，那么在这个 Message 被处理完后，就取消之前的延时任务，说明 UI 线程没有 block 。如果在指定的时间段内没有完成任务，说明 UI 线程有 block 。此时，异步线程可以执行刚才的延时任务。如果我们在这个延时任务里面打印 UI 线程的方法调用栈，就可以知道 UI 线程在做什么了。这个就是 UI 线程 block 检测的基本原理。 但是这个方案有一个缺点，就是无法处理 InputManager 的输入事件，比如 TV 端的遥控按键事件。通过对按键事件的调用方法链进行分析，发现最终每个按键事件都调用了 DecorView 类的 dispatchKeyEvent 方法，而非 Looper 的处理 Message 流程。所以 AndroidPerformanceMonitor 库是无法准确监控 TV 端应用 UI block 的情况。针对 TV 端应用按键处理，需要找到一个新的切入点，这个切入点就是刚刚的 DecorView 类的 dispatchKeyEvent 方法。 那如何介入 DecorView 类的 dispatchKeyEvent 方法呢？我们可以通过 epic 库来 hook 这个方法的调用。hook 成功后，我们可以在 DecorView 类的 dispatchKeyEvent 方法调用前后都接收到一个回调方法，在 dispatchKeyEvent 方法调用前我们可以在异步线程执行一个延时任务，在 dispatchKeyEvent 方法调用后，取消这个延时任务。如果 dispatchKeyEvent 方法耗时时间小于指定的时间阈值，延时任务在执行前被取消，可以认为没有 block ，此时移除了延时任务。如果 dispatchKeyEvent 方法耗时时间大于指定的时间阈值说明此时 UI 线程是有 block 的。此时，异步线程可以执行这个延时任务来收集必要的信息。 以上就是修改后的 UI 线程 block 的检测原理了，目前做的还比较粗糙，后续计划考虑参考 AndroidPerformanceMonitor 打印 CPU 、内存等更多的信息。 最终终端 log 打印效果如下： com.xander.performace.demo W/demo_Issue: ================================================= type: UI BLOCK msg: UI BLOCK create time: 2021-01-13 11:24:41 trace: java.lang.Thread.sleep(Thread.java:-2) java.lang.Thread.sleep(Thread.java:442) java.lang.Thread.sleep(Thread.java:358) com.xander.performance.demo.MainActivity.testANR(MainActivity.kt:49) java.lang.reflect.Method.invoke(Method.java:-2) androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:397) android.view.View.performClick(View.java:7496) android.view.View.performClickInternal(View.java:7473) android.view.View.access$3600(View.java:831) android.view.View$PerformClick.run(View.java:28641) android.os.Handler.handleCallback(Handler.java:938) android.os.Handler.dispatchMessage(Handler.java:99) android.os.Looper.loop(Looper.java:236) android.app.ActivityThread.main(ActivityThread.java:7876) java.lang.reflect.Method.invoke(Method.java:-2) com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656) com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967) FPS 检测的原理FPS 检测的原理，利用了 Android 的屏幕绘制原理。这里简单说下 Android 的屏幕绘制原理。 系统每隔 16 ms 就会发送一个 VSync 信号。 如果应用注册了这个 VSync 信号，就会在 VSync 信号到来的时候，收到回调，从而开始准备绘制。如果准备顺利，也就是 CPU 准备数据、GPU 栅格化等，如果这些任务在 16 ms 之内完成，那么下一个 VSync 信号到来前就可以绘制这一帧界面了。就没有掉帧，界面很流畅。如果在 16 ms 内没准备好，可能就需要更多的时间这个画面才能显示出来，在这种情况下就发生了丢帧，如果丢帧很多就卡顿了。 检测 FPS 的原理其实挺简单的，就是通过一段时间内，比如 1s，统计绘制了多少个画面，就可以计算出 FPS 了。那如何知道应用 1s 内绘制了多少个界面呢？这个就要靠 VSync 信号监听了。 在开始准备绘制前，往 UI 线程的 MessageQueue 里面放一个同步屏障，这样 UI 线程就只会处理异步消息，直到同步屏障被移除。刷新前，应用会注册一个 VSync 信号监听，当 VSync 信号到达的时候，系统会通知应用，让应用会给 UI 线程的 MessageQueue 里面放一个异步 Message 。由于之前 MessageQueue 里有了一个同步屏障，所以后续 UI 线程会优先处理这个异步 Message 。这个异步 Message 做的事情就是从 ViewRootImpl 开始我们熟悉的 measure 、layout 和 draw 。 我们可以通过 Choreographer 注册 VSync 信号监听。16ms 后，我们收到了 VSync 的信号，给 MessageQueue 里面放一个同步消息，我们不做特别处理，只是做一个计数，然后监听下一次的 VSync 信号，这样，我们就可以知道 1s 内我们监听到了多少个 VSync 信号，就可以得出帧率。 为什么监听到的 VSync 信号数量就是帧率呢？ 由于 Looper 处理 Message 是串行的，就是一次只处理一个 Message ，处理完了这个 Message 才会处理下一个 Message 。而绘制的时候，绘制任务 Message 是异步消息，会优先执行，绘制任务 Message 执行完成后，就会执行上面说的 VSync 信号计数的任务。如果忽略计数任务的耗时，那么最后统计到的 VSync 信号数量可以粗略认为是某段时间内绘制的帧数。然后就可以通过这段时间的长度和 VSync 信号数量来计算帧率了。 最终终端 log 打印效果如下： com.xander.performace.demo W/demo_FPSTool: APP FPS is: 54 Hz com.xander.performace.demo W/demo_FPSTool: APP FPS is: 60 Hz com.xander.performace.demo W/demo_FPSTool: APP FPS is: 60 Hz 线程的创建和启动监控以及线程池的创建监控线程和线程池的监控，主要是监控线程和线程池在哪里创建和执行的，如果我们可以知道这些信息，我们就可以比较清楚线程和线程池的创建和启动时机是否合理。从而得出优化方案。 一个比较容易想到的方法就是，应用代码里面的所有线程和线程池继承同一个线程基类和线程池基类。然后在构造函数和启动函数里面打印方法调用栈，这样我们就知道哪里创建和执行了线程或者线程池。 让应用所有的线程和线程池继承同一个基类，可以通过编译插件来实现，定制一个特殊的 Transform ，通过 ASM 编辑生成的字节码来改变继承关系。但是，这个方法有一定的上手难度，不太适合新手。 除了这个方法，我们还有另外一种方法，就是 hook 。通过 hook 线程或者线程池的构造方法和启动方法，我们就可以在线程或者线程池的构造方法和启动方法的前后做一些切片处理，比如打印当前方法调用栈等。这个也就是线程和线程池监控的基本原理。 线程池的监控没有太大难度，一般都是 ThreadPoolExecutor 的子类，所以我们 hook 一下 ThreadPoolExecutor 的构造方法就可以监控线程池的创建了。线程池的执行主要就是 hook 住 ThreadPoolExecutor 类的 execute 方法。 线程的创建和执行的监控方法就稍微要费些脑筋了，因为线程池里面会创建线程，所以这个线程的创建和执行应该和线程池绑定的。需要找到线程和线程池的联系，之前看到一个库，好像是通过线程和线程池的 ThreadGroup 来建立关联的，本来我也计划按照这个关系来写代码的，但是我发现，我们有的小伙伴写的线程池的 ThreadFactory 里面创建线程并没有传入ThreadGroup ，这个就尴尬了，就建立不了联系了。经过查阅相关源码发现了一个关键的类，ThreadPoolExecutor 的内部类Worker ，由于这个类是内部类，所以这个类实际的构造方法里面会传入一个外部类的实例，也就是 ThreadPoolExecutor 实例。同时， Worker 这个类还是一个 Runnable 实现，在 Worker 类通过 ThreadFactory 创建线程的时候，会把自己作为一个 Runnable 传给 Thread 所以，我们通过这个关系，就可以知道 Worker 和 Thread 的关联了。这样，我们通过 ThreadPoolExecutor 和 Worker 的关联，以及 Worker 和 Thread 的关联，就可以得到 ThreadPoolExecutor 和它创建的 Thread 的关联了。这个也就是线程和线程池的监控原理了。 最终终端 log 打印效果如下： com.xander.performace.demo W/demo_Issue: ================================================= type: THREAD msg: THREAD POOL CREATE create time: 2021-01-13 11:23:47 create trace: com.xander.performance.StackTraceUtils.list(StackTraceUtils.java:39) com.xander.performance.ThreadTool$ThreadPoolExecutorConstructorHook.afterHookedMethod(ThreadTool.java:158) de.robv.android.xposed.DexposedBridge.handleHookedArtMethod(DexposedBridge.java:265) me.weishu.epic.art.entry.Entry64.onHookObject(Entry64.java:64) me.weishu.epic.art.entry.Entry64.referenceBridge(Entry64.java:239) java.util.concurrent.Executors.newSingleThreadExecutor(Executors.java:179) com.xander.performance.demo.MainActivity.testThreadPool(MainActivity.kt:38) java.lang.reflect.Method.invoke(Method.java:-2) androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:397) android.view.View.performClick(View.java:7496) android.view.View.performClickInternal(View.java:7473) android.view.View.access$3600(View.java:831) android.view.View$PerformClick.run(View.java:28641) android.os.Handler.handleCallback(Handler.java:938) android.os.Handler.dispatchMessage(Handler.java:99) android.os.Looper.loop(Looper.java:236) android.app.ActivityThread.main(ActivityThread.java:7876) java.lang.reflect.Method.invoke(Method.java:-2) com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656) com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967) IPC(进程间通讯)监控的原理进程间通讯的具体原理，也就是 Binder 机制，这里不做详细的说明，也不是这个框架库的原理。 检测进程间通讯的方法和前面检测线程的方法类似，就是找到所有的进程间通讯的方法的共同点，然后对共同点做一些修改或者说切片，让应用在进行进程间通讯的时候，打印一下调用栈，然后继续做原来的事情。就达到了 IPC 监控的目的。 那如何找到共同点，或者说切片，就是本节的重点。 进程间通讯离不开 Binder ，需要从 Binder 入手。 写一个 AIDL demo 后发现，自动生成的代码里面，接口 A 继承自 IInterface 接口，然后接口里面有个内部抽象类 Stub 类，继承自 Binder ，同时实现了接口 A 。这个 Stub 类里面还有一个内部类 Proxy ，实现了接口 A ，并持有一个 IBinder 实例。 我们在使用 AIDL 的时候，会用到 Stub 类的 asInterFace 的方法，这个方法会新建一个 Proxy 实例，并给这个 Proxy 实例传入 IBinder , 或者如果传入的 IBinder 实例如果是接口 A 的话，就强制转化为接口 A 实例。一般而言，这个 IBinder 实例是 ServiceConnection 的回调方法里面的实例，是 BinderProxy 的实例。所以 Stub 类的 asInterFace 一般会创建一个 Proxy 实例，查看这个 Proxy 接口的实现方法，发现最终都会调用 BinderProxy 的 transact 方法，所以 BinderProxy 的 transact 方法是一个很好的切入点。 本来我也是计划通过 hook 住 BinderProxy 类的 transact 方法来做 IPC 的检测的。但是 epic 库在 hook 含有 Parcel 类型参数的方法的时候，不稳定，会有异常。由于暂时还没能力解决这个异常，只能重新找切入点。最后发现 AIDL demo 生成的代码里面，除了调用了 调用 BinderProxy 的 transact 方法外，还调用了 Parcel 的 readException 方法，于是决定 hook 这个方法来切入 IPC 调用流程，从而达到 IPC 监控的目的。 最终终端 log 打印效果如下： com.xander.performace.demo W/demo_Issue: ================================================= type: IPC msg: IPC create time: 2021-01-13 11:25:04 trace: com.xander.performance.StackTraceUtils.list(StackTraceUtils.java:39) com.xander.performance.IPCTool$ParcelReadExceptionHook.beforeHookedMethod(IPCTool.java:96) de.robv.android.xposed.DexposedBridge.handleHookedArtMethod(DexposedBridge.java:229) me.weishu.epic.art.entry.Entry64.onHookVoid(Entry64.java:68) me.weishu.epic.art.entry.Entry64.referenceBridge(Entry64.java:220) me.weishu.epic.art.entry.Entry64.voidBridge(Entry64.java:82) android.app.IActivityManager$Stub$Proxy.getRunningAppProcesses(IActivityManager.java:7285) android.app.ActivityManager.getRunningAppProcesses(ActivityManager.java:3684) com.xander.performance.demo.MainActivity.testIPC(MainActivity.kt:55) java.lang.reflect.Method.invoke(Method.java:-2) androidx.appcompat.app.AppCompatViewInflater$DeclaredOnClickListener.onClick(AppCompatViewInflater.java:397) android.view.View.performClick(View.java:7496) android.view.View.performClickInternal(View.java:7473) android.view.View.access$3600(View.java:831) android.view.View$PerformClick.run(View.java:28641) android.os.Handler.handleCallback(Handler.java:938) android.os.Handler.dispatchMessage(Handler.java:99) android.os.Looper.loop(Looper.java:236) android.app.ActivityThread.main(ActivityThread.java:7876) java.lang.reflect.Method.invoke(Method.java:-2) com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:656) com.android.internal.os.ZygoteInit.main(ZygoteInit.java:967) 联系我 Mail &#52;&#50;&#48;&#54;&#52;&#x30;&#55;&#x36;&#51;&#x40;&#113;&#113;&#x2e;&#99;&#111;&#109; 微信 参考资料: epic SandHook AndroidPerformanceMonitor 面试官：如何监测应用的 FPS ？ 深入探索Android卡顿优化（下）","categories":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/tags/Android/"},{"name":"Performance","slug":"Performance","permalink":"https://xanderwang.github.io/android-note/tags/Performance/"}]},{"title":"总结笔记(三) - Java 集合总结","slug":"总结笔记(三) - Java 集合总结","date":"2021-02-07T14:41:00.000Z","updated":"2021-02-28T07:55:56.187Z","comments":true,"path":"2021/02/07/总结笔记(三) - Java 集合总结/","link":"","permalink":"https://xanderwang.github.io/android-note/2021/02/07/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0(%E4%B8%89)%20-%20Java%20%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/","excerpt":"","text":"Java 集合总结Java 有哪些集合，继承关系是怎么样的 平时常用的集合有哪些 Collection List 可以重复添加元素 ArrayList LinkedList Set 不能重复添加元素 HashSet 不接受 null TreeSet Queue Deque PriorityQueue 数组实现，堆 ArrayDeque 数组实现， 2 个游标 Map 以键值对的形式保存值 HashMap LinkedHashMap TreeMap Hashtable ListArrayList数组实现，初始容量为 10，不够的时候扩容，扩容就是数组在当前长度基础上增大一倍。添加数据的时候，先判断容量是否够，不够就扩容，扩容完成后再添加。 缺点: 线程不安全 LinkedList链表实现。尾插法，即新节点插入到链表尾部。 SetHashSetJava 1.8 底层基于 HashMap 实现，HashMap 的 value 都是同一个对象。 TreeSetJava 1.8 默认是 TreeMap 实现，也可以给构造方法传入一个 NavigableMap(接口) 的实现实例。 QueueDeque双端队列， PriorityQueue堆，数组实现的 ArrayDequeMapHashMap最常用的一种结构，以数组为基础，数组元素为链表的复合结构。 需要注意的是： 初始容量为 16，默认承载因子为 0.75 ，需要注意的是，在指定容量的时候，如果不是 2 的指数，会计算一个大于指定容量，但是同时又是符合要求里面最小的一个 2 的指数作为容量。 当元素个数大于或等于(当前容量 * 承载因子)，就会扩容。 Java 1.7 插入数据的时候是头插法，即新的节点在链表头部。Java 1.8 及以后是尾插法，即新的节点在链表尾部。这个修改是为了解决扩容的时候可能会发生的死循环的问题。 Java 1.8 及以后，当同一个链表元素个数大于等于 (8 - 1) 的时候，会变成红黑树来存储，目的是提高效率。红黑树的转变是先比较 key 的 hash 大小，如果相同就尝试比较 key 自身。 无论是扩容，还是转成红黑树，都是先把节点放进去后再做扩容或者转换。 hash 碰撞，是指不同的 key, key 的 hash 和数组大小再次计算后,得出的索引一致。 hash 碰撞越少，HashMap 的效率越高。1.7 和 1.8 hash 算法有区别。 LinkedHashMap基于 HashMap 实现的，同时还是一个双向循环链表(比 HashMap 的节点多了个 before 和 after 指针)，在开启排序的情况下，最近使用过的节点(put、get)会放在链表尾部。 这个特性很适合 LRU 算法的实现，大概原理就是 LinkedHashMap 开启排序，然后最近使用的元素都在链表尾部，当链表长度大于指定长度的时候，就从链表头部开始删除，因为链表头部是最近没有使用的。 Hashtablesynchroinzed 实现线程安全，效率低下。 TreeMapTreeMap 在 Java 1.8 底层实现是一个红黑树，排序的规则是比较 key 的 “大小”。并且要求 key 的类型是需要可以比较的，并且 key 值不能为 null。 和 HashMap 一样，先插入数据，然后在重排序。 碰到的常见问题线程安全问题由于以上的都不是线程安全的，所以多线程的时候容易出问题，对于安全的线程有以下的几种 List Vector 通过方法添加 synchizoned 关键字实现，效率低下。 CopyOnWriteArrayList 每次写(添加，删除，修改)的时候，都会生成一个新副本，所以频繁的写操作会消耗大量内存。 Set CopyOnWriteArraySet 类似 CopyOnWriteArrayList Map ConcurrentHashMap Java 1.7 是通过分段锁实现，Java 1.8 是 CAS 和 synchroinzed 实现 ConcurrentHashMap分段锁来实现，分段锁可以提高效率，是因为如果不同线程的读写发生在不同的段上，实际上是没有锁竞争的，也就是没有线程被阻塞，所以效率高。 Java 1.7 及以前实现原理ConcurrentHashMap 有一个 segments 数组，这个数组元素的类型是 Segment，它继承自 ReentrantLock ，也就是说 Segment 是一个锁。 ConcurrentHashMap 插入或者修改数据的时候，会先找到是哪一个 segment , 然后在这个 segment 上面插入或者修改数据，而 segment 插入或者修改数据的时候，会先尝试获取锁，如果获取失败，说明有锁竞争，然后先尝试自旋，自旋超过次后，就开始阻塞线程。因此是线程安全的。 另外需要注意的是获取数据的时候没有加锁，因为是 volatile 变量，可以拿到最新的数据，但是呢， Java 1.8 及以后实现原理类似 HashMap ,放弃了分段锁，在插入或者修改数据的时候利用 cas 和 synchionzed 来保证线程安全，大概的原理就是先利用 cas 来设置，设置失败的时候说明有线程竞争，这个时候就用 synchionzed 来加锁，保证线程安全。 Java 1.8 之后，为何放弃了分段锁分段后，数据不连续，碎片较多，内存浪费严重，扩容等操作耗费大量的时间。 Java 1.8 是用的 synchornized + HashMap 来做的， synchornized jvm 层做了优化，同时 HashMap 也做了红黑树的优化，所以效率方面有保障。 主要方法总结List 接口- add(E):boolean - add(int, E):boolean - remove(int):E - remove(E):boolean - size():int Stack 类继承自 Vector , Vector 是一个同步安全的 List - push(E):E 入栈 - pop():E 出栈 - peek():E 查看顶部第一个元素 - search(Object):int - empty() 是否是空的 Set 接口- add(E):boolean - contains(Object):boolean - remove(Object):boolean - size():int Queue- add 添加元素，返回添加结果，如果不能添加就抛出异常 - remove 删除队列头，空队列异常 - element 返回队列头，空队列异常 - offer 添加元素，返回添加结果 - poll 返回并删除队列头，空队列的话返回 null - peek 返回队列头，空队列的话返回 null Map 接口- put(K, V):V - remove(Object):V - containsKey(Object):boolean - containsValue(Object):boolean - size():int ArrayMap 和 HashMapArrayMap 有缓存， HashMap 没有 内存小 深度解读ArrayMap优势与缺陷 SparseArray 和 ArrayList","categories":[{"name":"Java","slug":"Java","permalink":"https://xanderwang.github.io/android-note/categories/Java/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/tags/Android/"},{"name":"集合","slug":"集合","permalink":"https://xanderwang.github.io/android-note/tags/%E9%9B%86%E5%90%88/"}]},{"title":"总结笔记(二) - Java 反射和注解总结","slug":"总结笔记(二) - Java 反射和注解总结","date":"2021-02-07T14:41:00.000Z","updated":"2021-02-28T07:55:56.187Z","comments":true,"path":"2021/02/07/总结笔记(二) - Java 反射和注解总结/","link":"","permalink":"https://xanderwang.github.io/android-note/2021/02/07/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0(%E4%BA%8C)%20-%20Java%20%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/","excerpt":"","text":"反射总结什么是反射反射是 Java 语言的一个特性，就是在程序运行状态中，对于任何一个类，都可以通过反射知道这个类所有的方法和属性。对于任何一个实例，都可以调用这个实例的任何方法和属性。这个在运行时动态获取类或者实例的属性和方法，动态调用属性和方法的特性就叫反射。 反射有什么用从特性可以看出，在运行时可以动态调整属性的值和调用代码，可以让程序更灵活。主要用于以下几点 动态创建实例( class.newInstance 方法 ) 调用某个方法( method.invoke 方法 ) 修改或者获取某个字段的值 反射的常用方法介绍Class 常用方法介绍getDeclaringClass 一般针对内部类，如 B 是 A 的内部类，在 B 的 class 上调用这个方法，返回的是 A getDeclaredClasses 获取当前类声明的内部类 getClasses 包含当前类的父类和声明的 public 的内部类 newInstance 创建一个类的实例 forName 获取一个类，如果类没有加载会加载 getConstructor 系列方法，可以获取构造方法类实例，然后调用实例的 newInstance 方法可以获得一个实例 Method 常用方法介绍getMethod 获取 public 的方法，包括继承的 getDeclaredMethod 该类里面的定义的方法，包括私有的和实现的接口的方法。 invoke 该方法可以调用某个实例的某个方法。第一个参数为 null 时表示调用静态方法，第一个参数传入某个实例的时候，表示调用实例的某个方法。 Filed 常用方法介绍getField 获取字段 getDeclaredField 常用的场景动态配置可以通过 Class.forName 方法加载指定的配置类，然后读取配置，以达到动态配置的效果。 动态代理动态代理底层用到了反射。 hook 框架动态生成实例，修改字段值、调用非 public 方法 参考资料： 学习java应该如何理解反射？ 注解总结什么是注解注解是 JDK 1.5 引入的一个特性，用来给 Java 代码提供元数据。注解本身不直接影响代码的执行。 如何理解呢？注解是 Java 的一个特性，元数据可以理解为给编译器或者 jvm 看的++注释++，不直接影响程序的运行。但是可以在运行时通过读取注解做一些事情。可以把元数据理解为额外的一些可用可不用的额外信息。 注解定义和定义接口类似，只不过关键字是 @interface。下面一段代码演示了如何定义个注解 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface TestAnnotation &#123; int id(); String msg(); &#125; 注解的应用场景 提供信息给编译器 这个接触的不多 编译阶段的处理 比如生产文档，这个有时候会用 运行时的处理 这个相对用的多，就是说运行时读取注解的值，来做一些事情，比如 Retrofit 框架库，就用到了注解。具体的原理分析在后续笔记记录。 参考资料： java注解-最通俗易懂的讲解","categories":[{"name":"Java","slug":"Java","permalink":"https://xanderwang.github.io/android-note/categories/Java/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/tags/Android/"},{"name":"反射","slug":"反射","permalink":"https://xanderwang.github.io/android-note/tags/%E5%8F%8D%E5%B0%84/"},{"name":"注解","slug":"注解","permalink":"https://xanderwang.github.io/android-note/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"总结笔记(一) - 泛型总结","slug":"总结笔记(一) - 泛型总结","date":"2020-07-23T04:44:44.000Z","updated":"2021-02-28T07:55:56.187Z","comments":true,"path":"2020/07/23/总结笔记(一) - 泛型总结/","link":"","permalink":"https://xanderwang.github.io/android-note/2020/07/23/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0(%E4%B8%80)%20-%20%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/","excerpt":"","text":"泛型总结泛型是什么？一句话说就是类型参数化。什么意思呢？参数化的意思就是我们在定义的时候不知道具体的值，我们在到我们实际运行的时候才知道具体的值。类型参数化就是具体类型在定义的时候不知道，在实际运行的时候是确定的某一个类型。 Java 是如何实现泛型的？泛型是很多高级语言都有的特性。根据定义，泛型在运行时表示同一个类型，我们比较容易想到 List&lt;A&gt; 和 List&lt;B&gt; 用 2 个不同的 Class 表示，这个是可行的，但是 Java 由于需要兼容支持旧的代码，而且在推出泛型前就提供了容器类，这种方式(List&lt;A&gt; 和 List&lt;B&gt; 用 2 个不同的 Class)无法兼容以前的老代码，所以这个实现方法不适用。所以 Java 大佬们想了另外一种方式来实现泛型,这种方式就是类型擦除。 什么是泛型的类型擦除呢？类型擦除就是在实际生成字节码的时候，编译器源码里面定义的 List&lt;A&gt; 变成了 List&lt;Object&gt;,源码里面定义的 A Class 被擦除了，变成了 Object，同时在使用的时候，会强制类型转换，把取出来的 object 转成 A 的实例去使用。这就是类型擦除。 初步看，泛型擦除好像是没什么大的问题，但是仔细想想，在强制类型转换的时候，由于会丢掉类型的一些信息，会导致一些不符合预期的事情。比如有个基类 A，和它的两个子类 B 和 C ，然后我们有下面的一段代码。 List&lt;A&gt; listA = new ArrayList&lt;A&gt;(); listA.add(new B()); // 错误的， 第二行代码是不符合预期的，因为 listA 里面期望放的是 A 而不是 B。 但是这个好像不太符合预期，我们有时候希望子类是可以放进容器里面的。但是如果支持这个操作的话，会发生什么呢？取出来来的是 B 还是 C ？如果不能明确，那么就没有实现“泛型”。 为了解决这个问题， Java 大佬们想了个方法，提出了一些通配符来解决这些问题。 泛型的通配符 ?、extends 和 super在理解通配符之前，我们需要知道的是，通配符的发明是为了解决什么问题？至少要解决的一个问题是：容器里面放进去的是什么，取出来的就是什么。 这个问题，其实分两步，放进去，是说放进去同一种类型的东西。取出来，是说取出同一种类型的东西。或者说，用到通配符的地方应该是在不同的地方，一个地方把数据写到容器，另外一个地方把数据从容器拿出来，如果实在同一个代码块里写入和读取数据到同一个容器，应该是知道具体类型的，是不需要用到通配符的。 ? 通配符? 通配符称为无限通配符，表示不确定或者不关心类型。 extends 通配符一般称为上界通配符，表示的意思是：取值范围为 (某个类的子类, 某个类]。再想想我们之前说的，通配符要解决的问题？放进去的是什么，取出来的就应该是什么。放数据和取数据应用在不同的场景。如果我们在同一个场景，就不需要用到通配符了，因为类型是已知的。 通过上面的表述，容易推断出来 &lt;? extends E&gt; 的集合只能往外拿数据，因为取出来的一定是 E ，但是放进去的不知道是什么，可能是 E ，也可能是 E 的子类，如果允许往集合里面放东西，就不能保证放进去的是什么，拿出来的就是什么了。因为只能保证拿出来的是 E 。 这个特性也叫做协变。 super 通配符一般称为下界通配符，表示的意思是：取值范围为 [某个类，这个类的父类)。结合上面小节的解释，可以推断出 &lt;? super S&gt; 的集合只能往里面放数据，而不能从里面拿东西，为什么呢？因为 &lt;? extends E&gt; 解决的就是拿出来的问题啊，所以这个解决的就是放进去的问题啊，囧。里面放的是下限或者下限的子类。 这个特性也叫做逆变。 小结通配符与一个规则， PE-CS。 PE 简单的说，当只想从集合中获取元素，请把这个集合看成生产者，请使用&lt;? extends T&gt;，这就是 Producer extends 原则，PECS原则中的PE部分。集合生产元素后，就可以拿过来用了。 CS 简单的说，当你仅仅想增加元素到集合，把这个集合看成消费者，请使用&lt;? super T&gt;。这就是 Consumer super 原则，PECS原则中的CS部分。集合消费元素，这样就可以往里面放了 同时作为生产者和消费者的情况不存在，因为你可以指定具体的泛型。 参考资料： 深入理解 Java 泛型","categories":[{"name":"Java","slug":"Java","permalink":"https://xanderwang.github.io/android-note/categories/Java/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/tags/Android/"},{"name":"泛型","slug":"泛型","permalink":"https://xanderwang.github.io/android-note/tags/%E6%B3%9B%E5%9E%8B/"}]},{"title":"Android 性能优化总结","slug":"Android 性能优化总结","date":"2020-03-08T12:01:01.000Z","updated":"2021-02-28T07:55:56.183Z","comments":true,"path":"2020/03/08/Android 性能优化总结/","link":"","permalink":"https://xanderwang.github.io/android-note/2020/03/08/Android%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/","excerpt":"","text":"性能优化总结性能的优化是一个老生常谈的点，也是一个比较重要的点。现在对工作中的优化点做一个总结。 优化的方向，即那些点是需要优化的在平时的优化过程中我们需要从哪几个点来优化呢？其实我们平时自己一定也用过软件，在使用软件的过程中有没有什么想吐槽的呢？“太卡了吧！”、”图片怎么还没加载出来？”、”怎么刚进去就卡了。”等等，是不是有这样的想法，这些想法其实包含了我们今天要说的内容，就是从哪些方面来优化我们的 APP ，我总结了以下几点。 启动速度 操作流畅度 内存的管理和使用 图片的加载 当然，需要优化的不仅仅是这几个方面，我们暂时先就这几个方面来谈谈优化吧 启动速度启动速度是一个很关键的点，相信平时大家在使用软件的时候，如果点了应用的图标，结果很久才能进入主界面，很久才能操作。那么这个应用大概率会被卸载。 那我们如何优化我们的 APP 的启动速度呢？ 首先，第一步我们要知道我们的应用启动花的时间， 操作流畅度内存的管理和使用图片的加载","categories":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/tags/Android/"},{"name":"Performance","slug":"Performance","permalink":"https://xanderwang.github.io/android-note/tags/Performance/"},{"name":"优化","slug":"优化","permalink":"https://xanderwang.github.io/android-note/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"Android 学习大纲总结","slug":"Android 学习大纲总结","date":"2020-02-16T04:16:44.000Z","updated":"2021-02-28T07:55:56.183Z","comments":true,"path":"2020/02/16/Android 学习大纲总结/","link":"","permalink":"https://xanderwang.github.io/android-note/2020/02/16/Android%20%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2%E6%80%BB%E7%BB%93/","excerpt":"","text":"我的 Android 学习笔记 Java 基础 基础类型 循环控制 常见集合 数据结构 数组 队列 链表 栈 字典 树 基础控件 五种 Layout ImageView ListView RecyclerView Dialog 自定义控件 流程 属性自定义 Canvas 事件下发 四大组件 Activity Service Provider Broadcast 多媒体 其他 Jetpack 动画 Handler AsyncTask Manifast 跨进程通信 保活 传感器 震动 步数 指南针 FrameWork AMS PMS WMS 常用框架 图片 网络 异步 组件化 插件化 算法 八种排序算法 书籍推荐 我的 Android 学习笔记Java 基础基础类型Java 八大基本数据类型 循环控制Java控制语句 常见集合java常用集合类及其区别、源码分析（一） JAVA集合框架中的常用集合及其特点、适用场景、实现原理简介 数据结构数组Java数组的定义和使用 Java 数组基础 队列Java 集合深入理解（9）：Queue 队列 java队列——queue详细分析 链表【数据结构】链表的原理及java实现 Java链表实现以及链表倒置 栈Java 数据结构之 Stack(栈) java数据结构与算法之栈（Stack）设计与实现 字典Java map 详解 - 用法、遍历、排序、常用API等 Java Map集合的详解 树K：树、二叉树与森林之间的转换及其相关代码实现 基础控件五种 LayoutImageViewListViewRecyclerViewDialog自定义控件流程属性自定义Canvas事件下发四大组件ActivityServiceProviderBroadcast多媒体其他Jetpack动画HandlerAsyncTaskManifast跨进程通信保活传感器震动步数指南针FrameWorkAMSPMSWMS常用框架图片网络异步组件化插件化算法八种排序算法书籍推荐","categories":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://xanderwang.github.io/android-note/tags/Java/"}]}],"categories":[{"name":"编程基础","slug":"编程基础","permalink":"https://xanderwang.github.io/android-note/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"Java","slug":"Java","permalink":"https://xanderwang.github.io/android-note/categories/Java/"},{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/categories/Android/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"https://xanderwang.github.io/android-note/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"HTTP","slug":"HTTP","permalink":"https://xanderwang.github.io/android-note/tags/HTTP/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://xanderwang.github.io/android-note/tags/HTTPS/"},{"name":"三次握手","slug":"三次握手","permalink":"https://xanderwang.github.io/android-note/tags/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"},{"name":"Android","slug":"Android","permalink":"https://xanderwang.github.io/android-note/tags/Android/"},{"name":"Java 线程","slug":"Java-线程","permalink":"https://xanderwang.github.io/android-note/tags/Java-%E7%BA%BF%E7%A8%8B/"},{"name":"JVM","slug":"JVM","permalink":"https://xanderwang.github.io/android-note/tags/JVM/"},{"name":"hexo","slug":"hexo","permalink":"https://xanderwang.github.io/android-note/tags/hexo/"},{"name":"Github Action","slug":"Github-Action","permalink":"https://xanderwang.github.io/android-note/tags/Github-Action/"},{"name":"GitHub Page","slug":"GitHub-Page","permalink":"https://xanderwang.github.io/android-note/tags/GitHub-Page/"},{"name":"Performance","slug":"Performance","permalink":"https://xanderwang.github.io/android-note/tags/Performance/"},{"name":"集合","slug":"集合","permalink":"https://xanderwang.github.io/android-note/tags/%E9%9B%86%E5%90%88/"},{"name":"反射","slug":"反射","permalink":"https://xanderwang.github.io/android-note/tags/%E5%8F%8D%E5%B0%84/"},{"name":"注解","slug":"注解","permalink":"https://xanderwang.github.io/android-note/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"泛型","slug":"泛型","permalink":"https://xanderwang.github.io/android-note/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"优化","slug":"优化","permalink":"https://xanderwang.github.io/android-note/tags/%E4%BC%98%E5%8C%96/"},{"name":"Java","slug":"Java","permalink":"https://xanderwang.github.io/android-note/tags/Java/"}]}